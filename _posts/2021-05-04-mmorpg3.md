---
title: "[CS][게임네트워킹의 이해] 13. MMORPG 서버 구조 (3/3)"
excerpt: ""

categories:
  - TIL
tags:
  - CS
  - Network
 
last_modified_at: 2021-05-04T21:50:00
toc: true
toc_sticky: true
---

# MMORPG 서버 구조 3/3 (마지막)

- 싱글스레드 vs 멀티스레드와 싱글프로세스 vs 멀티프로세스는 아예 다른 이야기
- 싱글프로세스 + 멀티스레드 || 멀티프로세스 + 싱글스레드 조합이 일반적인 조합(싱글+싱글은 요즘 세상에 맞지 않는 조합)
- 현대 CPU의 발전은 클락수를 올리는데 한계를 느끼고 있고 이에 대한 대안으로 코어 수를 늘리는 중



## 멀티스레드

- 코어가 늘어난다고 해서 성능이 선형적으로 계속 증가하는 것이 아니라 오히려 스레드간의 간섭으로 인해서 성능이 떨어지는 경우가 발생. 이런 상황 때문에 싱글스레드+멀티프로세스 조합이 좋은 경우가 있는 것이다.
- 아무튼 그래서 스레드를 어떤 기준에서 어떻게 나누느냐가 멀티스레드에서는 매우 중요한 문제



### 스레드 나누는 방법

1. 무식하게 한다. 특별한 기준이 없이

   - waiting time이 길어져서 성능이 떨어짐
   - lock을 많이 걸다보니까 dead lock 상황이 많이 발생함. 발생하기 전에는 판단하기 어려운 문제가 있음. 데드락이 발생하면 프로그램이 멈춰버림
   - race condition 발생
     - 두 개 이상의 concurrent한 스레드들이 공유된 자원에 접근하려고 할 때 동기화 메커니즘 없이 접근하려고하는 상황을 말함
     - race condition의 경우 스레드의 실행 순서를 잘 조절해주지 않으면 비정상적인 상태가 나오게 됨

2. Actor 기준으로 나눈다. Akka 방식.

   - actor(캐릭터, npc 등)들이 각각의 스레드를 가지고 있음
   - 스레간에 락을 걸지 않음. 비동기식으로 처리
   - 게임은 actor간에 interaction이 빈번함. 
     - 만약 A가 B를 때렸을 때 B가 hp가 얼마나 남았는지 등을 알아야하기 때문에 스레드간의 통신이 필요함
     - 이를 서로간의 message 전송을 통해 실현
     - 자기한테 메시지 온 것만 처리하면 되니까 스레드간의 충돌이 없어짐. 서로간의 통신에 락을 걸 필요가 없어짐. 자원이 공유되지 않음. actor는 actor만의 자원을 점유하고 있음. **이상적으로는.**
     - 현실에서는 A가 B의 상태를 조회할 일이 있음.
     - 코딩 복잡도가 올라가고, 비동기식으로 하다보니까 메시지를 주고받는 시차, 타이밍 이슈가 존재한다.

3. system 기준으로 나눈다. ECS(Entity component system) 구조

   - entity : 컴포넌트를 가질 수 있는 단위

   - entity가 여러 component를 가지고 있음(npc가 flying, attack, talk 등의 컴포넌트를 가진 경우)
   - component는 데이터만 가지고 있지만 기능(function)을 가지고 있는 것이 아님. 클래스가 아님. C언어의 struct와 같음.
   - 기능은 전부 system에서 가지고 있음.(flying system, attack system 등) 데이터는 가지고 있지 않고 기능만 가지고 있는 것이 좋음.
   - 이 덕분에 시스템을 기준으로 스레드를 나눌 수 있어짐
   - MVC 모델의 게임 버전이라고 보면 됨.
     - Model, View, Control
   - 장점
     - Entity 확장이 쉬워짐. 엔터티가 새로 생겨도 그냥 컴포턴트 갖다가 끼면됨
     - 데이터 지역성이 좋아짐.
       - 같은 컴포넌트들은 array에 묶어둘 수가 있음.
       - system은 array를 돌면서 순차적으로 처리하면 되고, 캐시라인에 올려서 빠르게 처리할 수 있기 때문에 성능이 빨라진다.
       - 캐싱해두면 메모리에 다시 올릴 필요도 없고, 메모리에 엑세스 할 필요가 없으니까 성능이 빨라짐



## 시리즈 결론 소회? 

- 100퍼센트 내용을 다이해하지는 못했다. 이해도가 떨어져서 잘못된 메모를 했을수도 있다. 향후 서적을 통해 공부하면서 부족한 부분을 보강하고 간단한 서버를 만들어보면 이해가 깊어지길 기대한다. 백문이불여일코. 요즘 코딩을 많이 못하고 있고 코드도 많이 못 보고 있는데, 코딩 욕구가 지금 좀 크다. 
- 약 1년 전에 처음 go를 공부해보고 이 강의를 들었을 때는 뭔소린지 하나도 못알아들어서 중간에 관뒀었다. 1년이 지난 지금 다시 이강의를 들어보니 70~80퍼센트는 알아들을 수 있게 되었고,  끝까지 완강은 할 수 있었다. 1년 사이에 헛짓거리만 한것이 아니고 내가 많이 발전했구나라는 것을 이 기회에 깨달았다. 하지만 뭐 아직 갈 길이 먼 것도 맞다. 어쩌겠나. 이걸 업으로 삼기로 했고 그냥 매일매일 정진하는 것 밖에는 도리가 없다. 꾸준함이 답이다.



## 출처

- [Tucker Programming](https://www.youtube.com/channel/UCZp_ftx6UB_32VfVmlS3o_A)